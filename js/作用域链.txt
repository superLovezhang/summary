1.简单了解
  # 函数的作用域链是在声明时就已经建立，与调用环境无关，无法改变
  ## this的指向只与调用它的上下文对象决定，与声明环境无关

2.作用域的产生
  # 一个函数在声明时会自动创建一个活动对象
  ## 该活动对象包括了当前还有函数外一层的所有的形参数组arguments，函数内部声明的变量
     > eg: function fun(a1){ var name = 'ls' }
     >> 此时活动对象 { scopeChain:[{ agguments:[],name:undefinde},{ widow.Object }]  }

3.作用域的特点
  # 局部作用域可以访问全局作用域，反过来却不行
  ## 作用域是一环套一环，当前作用域没有自动向上一级寻找，找到停止并且返回，到window还没有找到返回undefinde


4.闭包
  # 可以访问局部作用域的函数
  ## 函数作用域的特点是当函数执行完毕就会自动销毁该内部的属性
  ### 在该函数内部 return 一个函数并且赋值给window属性上，由于子函数访问父函数内的属性，
      并且子函数被挂载到了全局作用域，所以父函数内部的属性不会自动销毁
  #### 闭包使用的解决了作用域访问问题，但是又带来了一些不必要的内存消耗